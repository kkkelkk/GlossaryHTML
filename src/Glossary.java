import java.util.Comparator;

import components.map.Map;
import components.map.Map1L;
import components.queue.Queue;
import components.queue.Queue1L;
import components.set.Set;
import components.set.Set1L;
import components.simplereader.SimpleReader;
import components.simplereader.SimpleReader1L;
import components.simplewriter.SimpleWriter;
import components.simplewriter.SimpleWriter1L;

/**
 * Simple HelloWorld program (clear of Checkstyle and FindBugs warnings).
 *
 * @author Baicen Wu
 */
public final class Glossary {

    /**
     * Compare {@code String}s in lexicographic order.
     */
    public static class StringLT implements Comparator<String> {
        @Override
        public int compare(String o1, String o2) {
            return o1.compareTo(o2);
        }
    }

    /**
     * Default constructor--private to prevent instantiation.
     */
    private Glossary() {
        // no code needed here
    }

    /**
     * Output the "opening" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * <html> <head> <title>webName</title> </head> <body>
     * <h2>webName</h2>
     * <hr />
     * <h3>Index</h3>
     *
     *
     * @param webName
     *            the name of the website
     * @param out
     *            the output stream
     * @updates out.content
     * @requires out.is_open and [WEBNAME_IS_NOT_EMPTY]
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     */
    public static void outputHeader(String nameOfHeader, SimpleWriter output) {
        assert nameOfHeader != null : "Violation of: Header is not null";
        assert output.isOpen() : "Violation of: out.is_open";

        /*
         * output the "opening" tags for the name and index
         */
        output.println("<html>");
        output.println("<head>");
        output.println("<title>" + nameOfHeader + "</title>");
        output.println("</head>");
        output.println("<body>");
        output.println("<h2>" + nameOfHeader + "</h2>");
        output.println("<hr />");
        output.println("<h3>Index</h3>");
    }

    /**
     * output a list of words and homepage footer in the output file.These are
     * the expected elements generated by this method:
     * <ul>
     * <li><a href="word.html">word</a></li> ...
     * </ul>
     * </body> </html>
     *
     * @param queueOfWords
     *            the {@code Queue<String>}
     * @param output
     *            the output stream
     * @updates out.content
     * @requires out.is_open and [QUEUE_IS_NOT_EMPTY]
     * @ensures <pre>
     * out.content = #out.content *
     *   [a list of words in the given file] * [footer]
     * </pre>
     */
    public static void outputWordsAndFooter(Queue<String> queueOfWords,
            SimpleWriter output) {
        assert output.isOpen() : "Violation of: out.is_open";
        assert queueOfWords != null : "Violation of: Queue is not null";

        /*
         * output each word as one of words in the list and hyperlink them
         * towards their definitions
         */
        for (int i = 0; i < queueOfWords.length(); i++) {
            String word = queueOfWords.dequeue();
            queueOfWords.enqueue(word);
            output.println("<ul>");
            output.println(
                    "<li><a href=\"" + word + ".html\">" + word + "</a></li>");
            output.println("</ul>");
        }
        /*
         * /output the "closing" tags
         */
        output.println("</body></html>");
    }

    /**
     * process each word by creating its HTML files. These are the expected
     * elements generated by this method: <html> <head> <title>word</title>
     * </head> <body>
     * <h2><b><i><font color="red">word</font></i></b></h2>
     * <blockquote>definition</blockquote>
     * <hr />
     * <p>
     * Return to <a href="webName.html">webName</a>.
     * </p>
     * </body> </html>
     *
     *
     * @param list
     *            the list of words and their definitions
     * @param word
     *            word to be processed
     * @param webName
     *            the name of the website
     * @param output
     *            the output stream
     * @updates out.content
     * @requires out.is_open, [WORD_IS_NOT_EMPTY] and [MAP_IS_NOT_EMPTY] and
     *           [WEBNAME_IS_NOT_EMPTY]
     * @ensure <pre>
     * out.content = #out.content *
     *   [the HTML tags]
     * </pre>
     */
    public static void processEachWord(Map<String, String> list,
            Set<Character> separatorSet, String eachWord,
            String fileNameForOutput, SimpleWriter output) {
        assert output.isOpen() : "Violation of: out.is_open";
        assert eachWord != null : "Violation of: Queue is not null";
        assert fileNameForOutput != null : "Violation of: Header is not null";
        assert list != null : "Violation of: list is not null";
        /*
         * store each word's definition as a string
         */
        String definition = list.value(eachWord);
        /*
         * output the opening tags for each term page and the header should be
         * red, bold and italic
         */
        output.println("<html>");
        output.println("<head><title>" + eachWord + "</title> </head>");
        output.println("<body>");
        output.println("<h2><b><i><font color=\"red\">" + eachWord
                + "</font></i></b></h2>");
        /*
         * use separator to find if the definition contains any of these terms.
         * if it does, hyperlink them to their own page
         */
        int position = 0;
        output.println("<blockquote>");
        while (position < definition.length()) {
            /*
             * get single word from definition
             */
            String token = nextWordOrSeparator(definition, position,
                    separatorSet);
            /*
             * if the list contains this word, hyperlink it if not, print it
             * normally
             */
            if (list.hasKey(token)) {
                output.print(
                        "<a href=\"" + token + ".html\">" + token + "</a>");
            } else {
                output.print(token);
            }
            position += token.length();
        }
        output.print("</blockquote>");
        /*
         * add a horizontal line below definitions and hyperlink the homepage
         */
        output.println("<hr />");
        output.println("<p> Return to <a href=\"" + fileNameForOutput
                + ".html\">" + fileNameForOutput + "</a></p>");
        output.println("</body> </html>");
    }

    /**
     * Inputs a "menu" of words and their definitions from the given file and
     * stores them in the given {@code Map}.
     *
     * @param input
     *            the given {@code SimpleReader}
     * @param list
     *            the {@code Map<String,String>} to be replaced
     * @param queueOfWords
     *            add each word into {@code Queue<String> queueOfWords}
     * @replaces list
     * @updates queueOfWords
     * @requires <pre>
     * [file has the format of one "word" (unique in the file) in the first line
     * and one or more definitions in the next line
     * , with whitespace between two words and their definitions; the "word"
     *  contains no whitespace]
     * </pre>
     * @ensures [list contains word -> words and definitions from file input]
     *          and queueOfWords = #queueOfWords * [words from given file ]
     */
    public static void generateListAndGetWords(Map<String, String> list,
            Queue<String> queueOfWords, SimpleReader input) {
        assert input != null : "Violation of: file is not null";
        /*
         * get words storing them into Map's key and Queue and get definitions
         * storing them into Map's value
         */
        while (!input.atEOS()) {
            String words = input.nextLine();
            String definitions = input.nextLine();
            String nextLine = input.nextLine();
            /*
             * if the next line of the file if empty, skip the empty line and
             * continue to get words and definitions
             */
            while (!nextLine.isEmpty()) {
                definitions += " " + nextLine;
                nextLine = input.nextLine();
            }
            list.add(words, definitions);
            queueOfWords.enqueue(words);

        }

    }

    /**
     * Generates the set of characters in the given {@code String} into the
     * given {@code Set}.
     *
     * @param str
     *            the given {@code String}
     * @param strSet
     *            the {@code Set} to be replaced
     * @replaces strSet
     * @ensures strSet = entries(str)
     */
    public static void generateElements(String str, Set<Character> strSet) {
        assert str != null : "Violation of: str is not null";
        assert strSet != null : "Violation of: strSet is not null";
        /*
         * generates the set of characters in the given string into the given
         * set
         */
        for (int i = 0; i < str.length(); i++) {
            if (!strSet.contains(str.charAt(i))) {
                strSet.add(str.charAt(i));
            }
        }
    }

    /**
     * Returns the first "word" (maximal length string of characters not in
     * {@code separators}) or "separator string" (maximal length string of
     * characters in {@code separators}) in the given {@code text} starting at
     * the given {@code position}.
     *
     * @param text
     *            the {@code String} from which to get the word or separator
     *            string
     * @param position
     *            the starting index
     * @param separators
     *            the {@code Set} of separator characters
     * @return the first word or separator string found in {@code text} starting
     *         at index {@code position}
     * @requires 0 <= position < |text|
     * @ensures <pre>
     * nextWordOrSeparator =
     *   text[position, position + |nextWordOrSeparator|)  and
     * if entries(text[position, position + 1)) intersection separators = {}
     * then
     *   entries(nextWordOrSeparator) intersection separators = {}  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      intersection separators /= {})
     * else
     *   entries(nextWordOrSeparator) is subset of separators  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      is not subset of separators)
     * </pre>
     */
    public static String nextWordOrSeparator(String text, int position,
            Set<Character> separators) {
        assert text != null : "Violation of: text is not null";
        assert separators != null : "Violation of: separators is not null";
        assert 0 <= position : "Violation of: 0 <= position";
        assert position < text.length() : "Violation of: position < |text|";

        char x = text.charAt(position);
        String wordOrSeparator = "";
        wordOrSeparator += x;
        position++;
        /*
         * if the character in the given position is not in the separators, this
         * string will be word before next character which is in the separators
         */
        if (!separators.contains(x)) {

            while (position < text.length()) {
                if (separators.contains(text.charAt(position))) {
                    break;
                } else {
                    wordOrSeparator += text.charAt(position);
                }
                position++;
            }
        }
        /*
         * if the character in the given position is in the separators, this
         * string will be separator before next character which is not in the
         * separators
         */
        else {
            while (position < text.length()) {
                if (separators.contains(text.charAt(position))) {
                    wordOrSeparator += text.charAt(position);
                } else {
                    break;
                }
                position++;
            }
        }

        return wordOrSeparator;

    }

    /**
     * Main method.
     *
     * @param args
     *            the command line arguments
     */
    public static void main(String[] args) {
        /*
         * Define separator characters for test
         */
        final String separatorStr = " \t, ";
        Set<Character> separatorSet = new Set1L<>();
        generateElements(separatorStr, separatorSet);
        /*
         * Open input and output streams
         */
        SimpleReader in = new SimpleReader1L();
        SimpleWriter out = new SimpleWriter1L();
        /*
         * ask users to enter the name of the file and open the file as
         * SimpleReader
         */
        out.print("Please enter the file: ");
        String fileName = in.nextLine();
        SimpleReader input = new SimpleReader1L(fileName);
        /*
         * create map to get each word with its definition inside the file and
         * queue to get each word without its definition
         */
        Map<String, String> list = new Map1L<>();
        Queue<String> queueOfWords = new Queue1L<>();
        generateListAndGetWords(list, queueOfWords, input);
        /*
         * call the comparator to lexicographically sort these words in queue
         */
        Comparator<String> order = new StringLT();
        queueOfWords.sort(order);

        /*
         * ask users to enter the name of the file and open a SimpleWriter to
         * print xml into the file
         */
        out.print("Please enter the name of the file to output: ");
        String fileNameForOutput = in.nextLine();
        SimpleWriter output = new SimpleWriter1L(
                "outputHTML/" + fileNameForOutput + ".html");
        /*
         * output the homepage
         */
        String nameOfHeader = "Glossary";
        outputHeader(nameOfHeader, output);
        outputWordsAndFooter(queueOfWords, output);
        /*
         * hyperlink each word in the list
         */
        for (int i = 0; i < list.size(); i++) {
            String word = queueOfWords.dequeue();
            queueOfWords.enqueue(word);
            SimpleWriter outputEachWord = new SimpleWriter1L(
                    "outputHTML/" + word + ".html");
            processEachWord(list, separatorSet, word, fileNameForOutput,
                    outputEachWord);
        }

        /*
         * Close input and output streams
         */
        in.close();
        input.close();
        out.close();
        output.close();
    }

}